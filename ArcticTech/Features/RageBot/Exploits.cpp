#include "Exploits.h"
#include "../../SDK/Globals.h"
#include "../../Utils/Console.h"
#include "../Misc/Prediction.h"

bool CExploits::IsCharged() {
	return ctx.tickbase_shift >= target_tickbase_shift;
}

bool CExploits::ShouldCharge() {
	if (!Cheat.LocalPlayer || GlobalVars->realtime - Cheat.LocalPlayer->m_flSpawnTime() < 0.2f || ClientState->m_nChokedCommands > 0)
		return false;


	fixed_recharge = false;
	return ctx.tickbase_shift < target_tickbase_shift;
}

bool CExploits::TeleportThisTick() {
	if (!teleport_next_tick)
		return false;

	if (ctx.active_weapon && (ctx.active_weapon->m_iItemDefinitionIndex() == Ssg08 || ctx.active_weapon->m_iItemDefinitionIndex() == Awp) && defensive_ticks > 0 && defensive_ticks < 13 && !config.ragebot.aimbot.doubletap_options->get(2))
		return false;

	return true;
}

void CExploits::Run() {
	should_override_next_tickbase_shift = false;
	override_next_tickbase_shift = 0;

	if (!ctx.cmd || !Cheat.LocalPlayer)
		return;

	exploit_type = E_None;

	if (!ctx.active_weapon)
		return;

	if (config.ragebot.aimbot.hide_shots->get())
		exploit_type = E_HideShots;
	if (config.ragebot.aimbot.doubletap->get())
		exploit_type = E_DoubleTap;

	if (exploit_type != E_None && force_charge && ctx.tickbase_shift != MaxTickbaseShift()) {
		target_tickbase_shift = MaxTickbaseShift();
		ctx.shifted_last_tick = 0;
		return;
	}

	if (exploit_type == E_None || (config.antiaim.misc.fake_duck->get() && !ctx.no_fakeduck) || config.ragebot.aimbot.force_teleport->get()) {
		target_tickbase_shift = 0;
		return;
	}

	const int max_tickbase_charge = MaxTickbaseShift();

	if (target_tickbase_shift < max_tickbase_charge) {
		if (!(GlobalVars->realtime - ctx.last_shot_time < 0.3f || GetAsyncKeyState(VK_LBUTTON) & 0x8000 || block_charge || !ctx.send_packet)) {
			target_tickbase_shift = max_tickbase_charge;
			ctx.shifted_last_tick = 0;
		}
	}
	else if (target_tickbase_shift > max_tickbase_charge) {
		target_tickbase_shift = max_tickbase_charge;
	}

	block_charge = false;

	if (IsCharged() && !fix_recharge) {
		fix_recharge = true;
	}
}

void CExploits::HandleTeleport(CL_Move_t cl_move) {
	if (TeleportThisTick()) {
		teleport_next_tick = false;
		target_tickbase_shift = 0;
	}

	shifting_tickbase = true;

	auto last_outgoing = &tickbase_info[ClientState->m_nLastOutgoingCommand % 150];
	int extra_commands = ctx.tickbase_shift - target_tickbase_shift;
	int cmdnum = ClientState->m_nLastOutgoingCommand + ClientState->m_nChokedCommands;

	if (extra_commands > 0) {
		auto tb_info = &tickbase_info[cmdnum % 150];
		tb_info->extra_commands = extra_commands;
		tb_info->tickbase_diff = tb_info->extra_commands - last_outgoing->extra_commands;
	}

	for (; ctx.tickbase_shift > target_tickbase_shift; --ctx.tickbase_shift) {
		last_teleport_time = GlobalVars->realtime;
		EnginePrediction->Update();
		cl_move(0.f, ctx.tickbase_shift == target_tickbase_shift);
		extra_commands++;
	}


	shifting_tickbase = false;
}

bool CExploits::IsHidingShot(CUserCmd* cmd) {
	return shot_cmd == cmd->command_number && exploit_type == E_HideShots;
}

int CExploits::MaxTickbaseShift() {
	return exploit_type == E_DoubleTap ? max_doubletap_speed : 9;
}

void CExploits::ForceTeleport() {
	if (ctx.tickbase_shift > 0) {
		teleport_next_tick = true;
	}
}

void CExploits::HideShot() {
	if (ctx.tickbase_shift > 0)
		shot_cmd = ctx.cmd->command_number;
}

void CExploits::DefensiveDoubletap() {
	if (exploit_type != E_DoubleTap || ctx.tickbase_shift == 0 || (ctx.active_weapon && (ctx.active_weapon->IsGrenade() || ctx.active_weapon->m_iItemDefinitionIndex() == Revolver))) {
		defensive_ticks = 0;
		in_defensive = false;
		return;
	}

	if (defensive_this_tick)
		in_defensive = true;

	auto skipped_ticks = [this](int need_to_skip) {
		int skipped = 0;

		for (int i = ctx.cmd->command_number - 1; i > ctx.cmd->command_number - 16; i--) {
			auto info = &tickbase_info[i % 150];

			if (!info->sent)
				continue;

			if (info->extra_commands > 0 || info->shift == 0)
				break;

			skipped++;

			if (skipped >= need_to_skip)
				return true;
		}

		return false;
	};

	if (in_defensive && (defensive_ticks > 0 || skipped_ticks(2)))
		defensive_ticks++;

	if (defensive_ticks > ctx.tickbase_shift) {
		defensive_ticks = 0;

		if (!defensive_this_tick)
			in_defensive = false;
	}
}

bool CExploits::ShouldBreakLC() {
	if (!Cheat.LocalPlayer)
		return false;

	if (ctx.tickbase_shift == 0 || ctx.planting_bomb)
		return false;

	if (shifting_tickbase)
		return false;

	bool result = false;

	if (exploit_type == E_DoubleTap) {
		if (config.ragebot.aimbot.doubletap_options->get(0))
			result = true;

		if (config.ragebot.aimbot.doubletap_options->get(1) && allow_defensive && in_defensive)
			result = defensive_ticks > 0;
	}

	return result;
}

void CExploits::LC_OverrideTickbase(int shift) {
	should_override_next_tickbase_shift = true;
	override_next_tickbase_shift = shift;

}

int CExploits::LC_TickbaseShift() {
	if (shifting_tickbase || ctx.tickbase_shift == 0 || ctx.planting_bomb)
		return 0;

	if (should_override_next_tickbase_shift)
		return override_next_tickbase_shift;

	if (ctx.active_weapon && ctx.active_weapon->IsGrenade() && reinterpret_cast<CBaseGrenade*>(ctx.active_weapon)->m_bPinPulled())
		return 0;

	if (exploit_type == E_DoubleTap)
		return ShouldBreakLC() ? ctx.tickbase_shift : 0;

	return abs(ctx.cmd->command_number - shot_cmd) < 4 ? ctx.tickbase_shift : 0;
}

void CExploits::Shift() {
	auto info = &tickbase_info[ctx.cmd->command_number % 150];

	if (!ctx.send_packet)
		return;

	info->sent = true;

	if (shifting_tickbase)
		return;

	int ticks_to_shift = LC_TickbaseShift();
	int next_cmd_nr = ctx.cmd->command_number + 1;

	CUserCmd fake_cmd = *ctx.cmd;
	fake_cmd.tick_count += 200;

	for (int command_number = next_cmd_nr; command_number < next_cmd_nr + ticks_to_shift; ++command_number) {
		CUserCmd* cmd = Input->GetUserCmd(command_number);

		*cmd = fake_cmd;
		cmd->hasbeenpredicted = true;
		cmd->command_number = command_number;
		//cmd->buttons &= ~(IN_ATTACK | IN_ATTACK2);

		CVerifiedUserCmd* verified_cmd = Input->GetVerifiedCmd(command_number);
		verified_cmd->cmd = *cmd;
		verified_cmd->crc = cmd->GetChecksum();

		ClientState->m_nChokedCommands++;
		info->extra_commands++;
		fake_cmd.tick_count++;
	}

	auto last_outgoing = &tickbase_info[ClientState->m_nLastOutgoingCommand % 150];

	info->tickbase_diff = info->extra_commands - last_outgoing->extra_commands;
}

bool CExploits::IsDefensiveActive() {
	return config.ragebot.aimbot.doubletap_options->get(1) && defensive_ticks > 0 && exploit_type == E_DoubleTap && ctx.tickbase_shift > 0 && !should_override_next_tickbase_shift;
}

void CExploits::PrePrediction() {
	ctx.corrected_tickbase = EnginePrediction->PredictTickbase() - ctx.tickbase_shift;

	if (charged_command + 1 == ctx.cmd->command_number)
		ctx.corrected_tickbase += ctx.shifted_last_tick;

	auto tb_info = &tickbase_info[ClientState->m_nLastOutgoingCommand % MULTIPLAYER_BACKUP];

	if (tb_info->command_number != ClientState->m_nLastOutgoingCommand)
		return;

	ctx.corrected_tickbase += tb_info->extra_commands;
}

void CExploits::NetUpdate() {
	if (!Cheat.InGame || !Cheat.LocalPlayer || !Cheat.LocalPlayer->IsAlive())
		return;

	auto ack_info = &tickbase_info[ClientState->m_nCommandAck % MULTIPLAYER_BACKUP];

	if (ack_info->command_number != ClientState->m_nCommandAck)
		return;

	if (ack_info->tickbase_ack != 0) // already acked
		return;

	ack_info->tickbase_ack = Cheat.LocalPlayer->m_nTickBase();

	if (!config.ragebot.aimbot.doubletap_options->get(4))
		return;

	int tickbase_diff = ack_info->tickbase - ack_info->tickbase_ack;

	if (!ack_info->shift || !ack_info->extra_commands || !ack_info->tickbase_diff || tickbase_diff >= 0 || tickbase_diff < -ctx.tickbase_shift)
		return;

	int to_charge = -tickbase_diff - 1;

	if (to_charge < 1 || to_charge > ctx.tickbase_shift - 3 || ctx.tickbase_shift == 0)
		return;

	ctx.tickbase_shift -= to_charge;
	ctx.shifted_last_tick = 0;
}

void CExploits::RunCommand(CUserCmd* cmd) {
	auto info = &tickbase_info[cmd->command_number % MULTIPLAYER_BACKUP];

	if (info->command_number != cmd->command_number)
		return;

	info->tickbase = Cheat.LocalPlayer->m_nTickBase();
}

void CExploits::UpdateTickbase() {
	auto info = &tickbase_info[ctx.cmd->command_number % MULTIPLAYER_BACKUP];

	info->command_number = ctx.cmd->command_number;
	info->tickcount = server_clock[ctx.cmd->command_number % 150].tick;
	info->tickbase = 0;
	info->tickbase_ack = 0;
	info->tickbase_diff = 0;
	info->extra_commands = 0;
	info->shift = ctx.tickbase_shift;
	info->sent = false;
}

void CExploits::AdjustPlayerTimeBase(int& m_nTickBase, CUserCmd* cmd) {
	auto info = &tickbase_info[cmd->command_number % MULTIPLAYER_BACKUP];

	if (info->command_number != cmd->command_number)
		return;

	int correct_ticks = -info->tickbase_diff;

	if (charged_command + 1 == cmd->command_number)
		correct_ticks += ctx.shifted_last_tick;

	m_nTickBase += correct_ticks;
}

int CExploits::GetInterpolateTick() {
	if (!ctx.tickbase_shift || !ctx.cmd || !InDefensive())
		return Cheat.LocalPlayer->m_nTickBase();

	int correct_cmd = -1;

	for (int i = ctx.cmd->command_number; i > ctx.cmd->command_number - 149; i--) {
		auto info = tickbase_info[i % MULTIPLAYER_BACKUP];

		if (!info.sent || info.command_number != i)
			continue;

		if (!info.extra_commands || info.tickbase_diff != 0 || !info.tickbase_ack)
			continue;

		correct_cmd = i;
		break;
	}

	if (correct_cmd == -1)
		return Cheat.LocalPlayer->m_nTickBase();

	auto correct_info = tickbase_info[correct_cmd % MULTIPLAYER_BACKUP];

	return correct_info.tickbase_ack + (ctx.cmd->command_number - correct_info.command_number);
}

void CExploits::UpdateServerClock(int tick) {
	auto& clock = server_clock[ClientState->m_nCommandAck % 150];

	clock.command_number = ClientState->m_nCommandAck;
	clock.tick = tick;
	clock.receive_time = GlobalVars->realtime;
	clock.receive_latency = 0.f;
	if (auto nci = EngineClient->GetNetChannelInfo())
		clock.receive_latency = nci->GetLatency(FLOW_INCOMING);
}

int CExploits::GetServerTick(int command_number) { //approximate
    float latency = 0.0f;
    if (auto nci = EngineClient->GetNetChannelInfo())
        latency = nci->GetLatency(FLOW_OUTGOING);

    int base_server_tick = ClientState->m_ClockDriftMgr.m_nServerTick + TIME_TO_TICKS(latency);
    int command_delta = command_number - ClientState->m_nLastOutgoingCommand;

    return base_server_tick + command_delta;
}

CExploits* Exploits = new CExploits;